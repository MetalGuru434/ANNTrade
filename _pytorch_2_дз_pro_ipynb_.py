# -*- coding: utf-8 -*-
""""PyTorch #2.ДЗ PRO.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RMLQpFHz9tcN6_EoqDLGwHCyErPtRI2e

# Задание Pro

Необходимо, на основании представленного датасета 'https://storage.yandexcloud.net/aiueducation/Content/base/l5/middle_fmr.zip', разработать свёрточную нейросеть на PyTorch.

Рекомендации по выполнению задания:

1. Создать общую выборку из тензоров;
2. Разделить общую выборку на: тренировочную, валидационную, тестовую;
3. Создать архитектуру свёрточной нейросети, применяя следуюшие слои: Linear, Conv2D, Max Pooling, Average Pooling, Dropout, Batch Normalization;
4. Обучить модель нейросети, применяя метрики: "Loss ("Потери", "Ошибка")" и "Accuracy ("Точность")";
5. Показать результат обучения модели на тестовой выборке.

# Подготовка
"""

# Подключение модуля для загрузки данных из облака
import gdown

# Загрузка zip-архива с датасетом из облака на диск виртуальной машины colab
gdown.download('https://storage.yandexcloud.net/aiueducation/Content/base/l5/middle_fmr.zip', None, quiet=True)

# Разархивация датасета в директорию 'content/cars'
!unzip -qo "middle_fmr.zip" -d cars/

# Папка с папками картинок, рассортированных по категориям
IMAGE_PATH = 'cars/'

# Для работы с файлами
import os

os.listdir(IMAGE_PATH)

# Определение списка имен классов
CLASS_LIST = sorted(os.listdir(IMAGE_PATH))

# Определение количества классов
CLASS_COUNT = len(CLASS_LIST)

# Проверка результата
print(f'Количество классов: {CLASS_COUNT}, метки классов: {CLASS_LIST}')

i = 1

# Формирование пути к выборке одной марки авто
f'{IMAGE_PATH}{CLASS_LIST[i]}/'

from time import sleep as sl

for cls in CLASS_LIST:
    print(cls, ':', os.listdir(f'{IMAGE_PATH}{cls}/'))
    sl(0.5)

from PIL import Image                     # Отрисовка изображений
import random                             # Генерация случайных чисел
import matplotlib.pyplot as plt           # Отрисовка графиков

# Создание заготовки для изображений всех классов
fig, axs = plt.subplots(1, CLASS_COUNT, figsize=(25, 5))

# Для всех номеров классов:
for i in range(CLASS_COUNT):
    # Формирование пути к папке содержимого класса
    car_path = f'{IMAGE_PATH}{CLASS_LIST[i]}/'
    # Выбор случайного фото из i-го класса
    img_path = car_path + random.choice(os.listdir(car_path))
    # Отображение фотографии (подробнее будет объяснено далее)
    axs[i].set_title(CLASS_LIST[i])
    axs[i].imshow(Image.open(img_path))
    axs[i].axis('off')

# Отрисовка всего полотна
plt.show()

"""## Создание списков файлов и их меток класса

"""

CLASS_COUNT

data_files = []                           # Cписок путей к файлам картинок
data_labels = []                          # Список меток классов, соответствующих файлам

for class_label in range(CLASS_COUNT):    # Для всех классов по порядку номеров (их меток)
    class_name = CLASS_LIST[class_label]  # Выборка имени класса из списка имен
    class_path = IMAGE_PATH + class_name  # Формирование полного пути к папке с изображениями класса
    class_files = os.listdir(class_path)  # Получение списка имен файлов с изображениями текущего класса
    print(f'Размер класса {class_name} составляет {len(class_files)} машин')

    # Добавление к общему списку всех файлов класса с добавлением родительского пути
    data_files += [f'{class_path}/{file_name}' for file_name in class_files]

    # Добавление к общему списку меток текущего класса - их ровно столько, сколько файлов в классе
    data_labels += [class_label] * len(class_files)

print('Общий размер базы для обучения:', len(data_labels))

import numpy as np
plt.style.use('ggplot')

count_labels = np.array(data_labels)
count = np.bincount(count_labels)

plt.bar(range(3), count, color=['#990099', '#006666', '#003399'])
plt.xlabel(f'Классы:{count}', c='#9900ff')
plt.ylabel('Количество', c='#9900ff')
plt.xticks([0, 1, 2])
plt.title('График количества элементов по классам', c='#996600')
plt.show()

count = np.bincount(count_labels)

"""Теперь в списках находятся пути к файлам и соответствующие им номера классов:

"""

print('Пути к файлам: ', data_files[1085:1090])
print('Их метки классов:', data_labels[1085:1090])

"""## Формирование набора данных из имеющейся базы

"""

# Задание единых размеров изображений

IMG_WIDTH = 128                           # Ширина изображения
IMG_HEIGHT = 64                           # Высота изображения

data_files[0]

import numpy as np                        # Библиотека работы с массивами

data_images = []                          # Пустой список для данных изображений

for file_name in data_files:
    # Открытие и смена размера изображения
    img = Image.open(file_name).resize((IMG_WIDTH, IMG_HEIGHT))
    img_np = np.array(img)                # Перевод в numpy-массив
    data_images.append(img_np)            # Добавление изображения в виде numpy-массива к общему списку

x_data = np.array(data_images)            # Перевод общего списка изображений в numpy-массив
y_data = np.array(data_labels)            # Перевод общего списка меток класса в numpy-массив

print(f'В массив собрано {len(data_images)} фотографий следующей формы: {img_np.shape}')
print(f'Общий массив данных изображений следующей формы: {x_data.shape}')
print(f'Общий массив меток классов следующей формы: {y_data.shape}')

x_data[0]

# Нормированние массива изображений
x_data = x_data / 255.

"""# Решение"""

# Ваше решение